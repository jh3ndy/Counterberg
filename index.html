<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Days Countdown</title>
    <!-- Tailwind CSS for modern, responsive styling --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas container */
        .canvas-container {
            max-width: 600px;
            width: 90%;
            margin: 0 auto;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5); /* Stronger shadow for dark mode */
            background-color: #262626; /* Darker background for the card */
            overflow: hidden;
        }
        #icebergCanvas {
            display: block;
            width: 100%;
            height: 400px; /* Fixed height for the drawing area */
        }
    </style>
</head>
<!-- Use dark grey background for the body --><body class="bg-neutral-900 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <div class="text-center mb-10 w-full max-w-xl">
        <!-- Neon Green Title --><h1 class="text-4xl sm:text-5xl font-extrabold text-green-400 mb-2">
            Countdown to Freedom!
        </h1>
        <!-- Light Grey Subtitle --><p id="subtitle" class="text-neutral-400 text-lg mb-6">Days of School Remaining</p>
        <!-- Neon Green Counter Box --><div id="countdown" class="text-6xl sm:text-8xl font-black text-neutral-900 p-6 rounded-xl bg-green-500 shadow-xl transition duration-300">
            Calculating...
        </div>
    </div>

    <!-- Canvas Container for the Iceberg Visualization --><div class="canvas-container shadow-2xl">
        <canvas id="icebergCanvas"></canvas>
    </div>

    <script>
        // --- Configuration Constants ---
        // The total number of school days, confirmed to be 40 (Tue-Fri only).
        const MAX_SCHOOL_DAYS = 40; 
        const START_DATE_STR = '2025-11-25T00:00:00'; // First day (Day 40 remaining)
        const BREAK_START_STR = '2025-12-20T00:00:00'; // Holiday starts (Dec 20th is the first non-school day)
        const BREAK_END_STR = '2026-01-06T00:00:00'; // School resumes (Jan 6th IS counted)
        
        const START_DATE = new Date(START_DATE_STR);
        const BREAK_START = new Date(BREAK_START_STR);
        const BREAK_END_EXCLUSIVE = new Date(BREAK_END_STR);
        
        /**
         * Checks if a given date is a school day based on the defined rules (Tue-Fri only).
         * @param {Date} date - The date to check.
         * @returns {boolean} True if it is a school day.
         */
        function isSchoolDay(date) {
            // Day of week: 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
            const day = date.getDay();

            // 1. Check for Non-School Days (Mon, Sat, Sun)
            // Days 0 (Sun), 1 (Mon), and 6 (Sat) are excluded.
            if (day === 0 || day === 1 || day === 6) {
                return false;
            }

            // 2. Check Holiday Break (Dec 20, 2025 up to Jan 5, 2026, inclusive)
            // Note: Jan 6th (BREAK_END_EXCLUSIVE) IS counted.
            if (date >= BREAK_START && date < BREAK_END_EXCLUSIVE) {
                return false;
            }

            return true;
        }

        /**
         * Calculates the number of remaining school days up to a given date.
         * @param {Date} simulatedDate - The date to calculate up to (defaults to today).
         */
        function calculateDaysRemaining(simulatedDate = new Date()) {
            const checkDate = new Date(simulatedDate);
            // Reset time to midnight for accurate day comparison
            checkDate.setHours(0, 0, 0, 0);

            // If the date is before the start date, the full count remains
            if (checkDate < START_DATE) {
                return MAX_SCHOOL_DAYS;
            }

            let daysBeforeTarget = 0;
            let currentDate = new Date(START_DATE);

            // Iterate through every day from START_DATE up to (but not including) the target date
            while (currentDate < checkDate) {
                if (isSchoolDay(currentDate)) {
                    daysBeforeTarget++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Days remaining = Total count (40) - Days elapsed
            const daysRemaining = Math.max(0, MAX_SCHOOL_DAYS - daysBeforeTarget);
            
            return daysRemaining;
        }

        /**
         * Draws a sliver moon in the upper right corner, using clipping to ensure a crisp edge.
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
         * @param {number} W - Canvas width.
         * @param {string} color - Color of the moon.
         */
        function drawMoon(ctx, W, color) {
            const moonRadius = W * 0.05; // Relative size
            const moonCenterX = W - moonRadius * 2.5;
            const moonCenterY = moonRadius * 1.5;

            ctx.fillStyle = color;
            ctx.beginPath();
            
            // 1. Draw the full circle that defines the outer edge of the moon
            ctx.arc(moonCenterX, moonCenterY, moonRadius, 0, Math.PI * 2, false);
            
            // 2. Set the clipping path to this outer circle
            ctx.save(); // Save the canvas state before clipping
            ctx.clip(); 
            
            // 3. Draw the inner circle (the 'bite')
            // This inner circle will only be visible where it overlaps with the outer circle, 
            // but since it's the same color as the sky, it essentially erases that portion.
            
            // Draw a circle slightly smaller than the outer radius, offset to create the crescent
            // Since we clip, we can simply fill the canvas with the sky color, and only the 
            // part NOT overlapped by the second shape will remain in the clipping area.
            
            // Instead of clipping and filling, let's just use the shape drawing method correctly
            // to ensure anti-aliasing doesn't create artifacts.
            
            // Correct Crescent Drawing (Using two intersecting arcs in a single path)
            ctx.beginPath();
            // Outer edge (starting from the top)
            ctx.arc(moonCenterX, moonCenterY, moonRadius, Math.PI * 0.5, Math.PI * 1.5, true); 
            // Inner edge (convex curve)
            ctx.arc(moonCenterX - moonRadius * 0.4, moonCenterY, moonRadius * 0.9, Math.PI * 1.5, Math.PI * 0.5, false);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore(); // Restore the canvas state (removes the clipping path)
        }


        /**
         * Draws the dynamic iceberg visualization on the canvas, matching the reference image.
         * @param {number} daysRemaining - The current number of school days left (0 to 40).
         */
        function drawIceberg(daysRemaining) {
            const canvas = document.getElementById('icebergCanvas');
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;
            ctx.clearRect(0, 0, W, H);

            // Calculate progress: 0 (Day MAX_SCHOOL_DAYS) to 1 (Day 0)
            const progress = (MAX_SCHOOL_DAYS - daysRemaining) / MAX_SCHOOL_DAYS;
            
            // Overall reduction factor (1.0 at day 40, approaches 0 at day 0)
            const sizeFactor = daysRemaining / MAX_SCHOOL_DAYS; 
            
            // The initial, maximum scale for geometry definitions
            const MAX_BASE_SCALE = W * 0.25; 
            
            // --- Drawing Parameters ---
            const centerX = W / 2;
            const waterLevelY = H * 0.5; // Fixed water line

            // Buoyancy: Lift the iceberg as it gets smaller (progress goes from 0 to 1)
            const verticalLift = MAX_BASE_SCALE * 0.2 * progress; 
            
            // Chipping: Introduce non-symmetrical, fixed variance based on remaining days.
            const shapingSeed = Math.sin(daysRemaining * 1.5 + daysRemaining / 5) * 0.5 + 0.5; // Predictable pseudo-random (0 to 1)
            const chippingVariance = MAX_BASE_SCALE * 0.1 * progress; // Max variance increases as it melts

            // --- New Color Palette for Dark Theme (Shades of Pink and Dark Water) ---
            const skyBgColor = '#36364a';      // Dark Grey Sky/Progress Empty
            const skyProgressColor = '#5f5f7a'; // Lighter Grey Sky/Progress Filled
            const waterColor = '#0a1931';       // Very Dark Ocean Blue

            // Iceberg - Shades of Pink
            const visibleLight = '#FFD1DC'; // Light Pink
            const visibleMid = '#FFB6C1';   // Medium Pink
            const visibleDark = '#FF69B4';   // Dark Pink/Rose
            const textureCreviceColor = '#C799A5'; // Muted Pink/Red
            const textureHighlightColor = '#FCE4EC'; // Bright Light Pink
            
            // Submerged - Darker, Muted Colors
            const submergedDarkBlue = '#0d2d4f'; 
            const submergedLightBlue = '#1a4f7e';
            const submergedHighlightBlue = '#2b6f9e';


            // --- 1. Draw Water and Sky (Now a Progress Bar) ---
            
            // Sky Background (Progress Empty - Dark Grey)
            ctx.fillStyle = skyBgColor;
            ctx.fillRect(0, 0, W, waterLevelY);
            
            // Sky Progress Bar (Lighter Grey, fills based on progress)
            const progressWidth = W * progress;
            ctx.fillStyle = skyProgressColor;
            ctx.fillRect(0, 0, progressWidth, waterLevelY);

            // Draw the moon in the sky
            drawMoon(ctx, W, textureHighlightColor);


            // Water (Deep Ocean)
            ctx.fillStyle = waterColor;
            // Overlap by 1 pixel to remove the horizontal artifact at the water line
            ctx.fillRect(0, waterLevelY - 1, W, H - waterLevelY + 1);
            
            // Check if the iceberg is completely melted (Day 0)
            if (daysRemaining <= 0) {
                 // Skip drawing the iceberg geometry, only the water line remains
                 // Neon Green Water Line
                ctx.beginPath();
                ctx.moveTo(0, waterLevelY);
                ctx.lineTo(W, waterLevelY);
                ctx.strokeStyle = '#34D399'; // Neon Green
                ctx.lineWidth = 4;
                ctx.stroke();
                return; 
            }


            // --- 2. Define Iceberg Points (Shrinking/Chipping Logic) ---
            
            // Internal Texture Points (T1-T4)
            const T1 = {
                x: (-0.05 * MAX_BASE_SCALE + chippingVariance * shapingSeed * 0.2) * sizeFactor, 
                y: (-0.4 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor
            };
            const T2 = {
                x: (0.15 * MAX_BASE_SCALE - chippingVariance * (1 - shapingSeed) * 0.2) * sizeFactor, 
                y: (-0.5 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor
            };
            const T3 = {
                x: (-0.18 * MAX_BASE_SCALE) * sizeFactor, 
                y: (-0.2 * MAX_BASE_SCALE + verticalLift * 0.8) * sizeFactor
            };
            const T4 = {
                x: (0.05 * MAX_BASE_SCALE) * sizeFactor, 
                y: (-0.15 * MAX_BASE_SCALE + verticalLift * 0.8) * sizeFactor
            };


            // Visible Part Points (P0-P6) - Applying chipping to the peak
            const topPoints = [
                // P0, P1, P2 are the peak points, get the most dramatic variance
                {x: (-0.1 * MAX_BASE_SCALE) * sizeFactor, y: (-0.7 * MAX_BASE_SCALE + verticalLift + chippingVariance * shapingSeed * 0.8) * sizeFactor}, 
                {x: (0 * MAX_BASE_SCALE + chippingVariance * (1 - shapingSeed) * 0.4) * sizeFactor, y: (-0.8 * MAX_BASE_SCALE + verticalLift + chippingVariance * (1 - shapingSeed) * 0.8) * sizeFactor}, 
                {x: (0.1 * MAX_BASE_SCALE) * sizeFactor, y: (-0.7 * MAX_BASE_SCALE + verticalLift - chippingVariance * shapingSeed * 0.8) * sizeFactor}, 
                
                {x: (0.3 * MAX_BASE_SCALE) * sizeFactor, y: (-0.3 * MAX_BASE_SCALE + verticalLift) * sizeFactor}, // P3: Far right middle
                {x: (0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P4: Right waterline (WL_R)
                {x: (-0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P5: Left waterline (WL_L)
                {x: (-0.3 * MAX_BASE_SCALE) * sizeFactor, y: (-0.3 * MAX_BASE_SCALE + verticalLift) * sizeFactor}, // P6: Far left middle
            ];

            // Submerged Part Points (Symmetrically shrinking and rising)
            const submergedPoints = [
                {x: (-0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P0: Left waterline
                {x: (0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P1: Right waterline
                {x: (0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0.3 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor}, 
                {x: (0.15 * MAX_BASE_SCALE) * sizeFactor, y: (0.6 * MAX_BASE_SCALE + verticalLift * 0.2) * sizeFactor}, 
                {x: (0 * MAX_BASE_SCALE) * sizeFactor, y: (0.8 * MAX_BASE_SCALE + verticalLift * 0.1) * sizeFactor}, 
                {x: (-0.15 * MAX_BASE_SCALE) * sizeFactor, y: (0.6 * MAX_BASE_SCALE + verticalLift * 0.2) * sizeFactor}, 
                {x: (-0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0.3 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor}, 
            ];

            // Helper to offset points to canvas coordinates
            const offsetPoints = (points, offsetY = waterLevelY) => points.map(p => ({
                x: centerX + p.x,
                y: offsetY + p.y
            }));

            const visiblePts = offsetPoints(topPoints, waterLevelY);
            const submergedPts = offsetPoints(submergedPoints, waterLevelY);
            const internalPts = offsetPoints([T1, T2, T3, T4], waterLevelY);

            // Alias key points for drawing clarity
            const P0 = visiblePts[0]; const P1 = visiblePts[1]; const P2 = visiblePts[2];
            const P3 = visiblePts[3]; const P4 = visiblePts[4]; const P5 = visiblePts[5];
            const P6 = visiblePts[6];
            const T_A = internalPts[0]; const T_B = internalPts[1];
            const T_C = internalPts[2]; const T_D = internalPts[3];

            // --- Draw Subtle Water Ripple (BEFORE the iceberg) ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'; // Lower opacity
            ctx.lineWidth = 0.5; // Thinner lines to blend better
            for (let i = 0; i < 2; i++) { 
                const yOffset = waterLevelY + 15 + i * 10; // Deeper in the water
                
                // Add minor random variance to start/end X to make it less boxy
                const waveOffset = Math.sin(i * 0.9 + progress * 5 + Date.now()/10000) * 10;
                const startX = W * 0.15 + waveOffset;
                const endX = W * 0.85 - waveOffset;

                ctx.beginPath();
                ctx.moveTo(startX, yOffset);
                ctx.bezierCurveTo(
                    W * 0.3 + Math.random() * 20, yOffset + Math.sin(i + progress * 10) * 2,
                    W * 0.7 - Math.random() * 20, yOffset - Math.cos(i + progress * 10) * 2,
                    endX, yOffset
                );
                ctx.stroke();
            }


            // --- 3. Draw Iceberg Submerged Part (Dark/Muted Blues) ---
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Main submerged shape (darkest base)
            ctx.beginPath();
            ctx.moveTo(submergedPts[0].x, submergedPts[0].y); 
            ctx.lineTo(submergedPts[6].x, submergedPts[6].y); 
            ctx.lineTo(submergedPts[5].x, submergedPts[5].y); 
            ctx.lineTo(submergedPts[4].x, submergedPts[4].y); 
            ctx.lineTo(submergedPts[3].x, submergedPts[3].y); 
            ctx.lineTo(submergedPts[2].x, submergedPts[2].y); 
            ctx.lineTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.closePath();
            ctx.fillStyle = submergedDarkBlue;
            ctx.fill();

            // Lighter submerged facet (right side)
            ctx.beginPath();
            ctx.moveTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.lineTo(submergedPts[2].x, submergedPts[2].y); 
            ctx.lineTo(submergedPts[3].x, submergedPts[3].y); 
            ctx.closePath();
            ctx.fillStyle = submergedLightBlue;
            ctx.fill();

            // Submerged highlight (middle triangle)
            ctx.beginPath();
            ctx.moveTo(submergedPts[0].x, submergedPts[0].y); 
            ctx.lineTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.lineTo(submergedPts[4].x, submergedPts[4].y); 
            ctx.closePath();
            ctx.fillStyle = submergedHighlightBlue;
            ctx.fill();


            // --- 4. Draw Iceberg Visible Part (Shades of Pink) ---

            // Main visible shape (largest face - visibleMid base)
            ctx.beginPath();
            ctx.moveTo(P5.x, P5.y); // Left waterline
            ctx.lineTo(P6.x, P6.y); // Far left middle
            ctx.lineTo(P0.x, P0.y); // Left-most peak facet
            ctx.lineTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P2.x, P2.y); // Right-most peak facet
            ctx.lineTo(P3.x, P3.y); // Far right middle
            ctx.lineTo(P4.x, P4.y); // Right waterline
            ctx.closePath();
            ctx.fillStyle = visibleMid;
            ctx.fill();

            // Front-right facet (lighter)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P2.x, P2.y); // Right-most peak facet
            ctx.lineTo(P3.x, P3.y); // Far right middle
            ctx.closePath();
            ctx.fillStyle = visibleLight;
            ctx.fill();
            
            // Front-left facet (darker)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P0.x, P0.y); // Left-most peak facet
            ctx.lineTo(P6.x, P6.y); // Far left middle
            ctx.closePath();
            ctx.fillStyle = visibleDark;
            ctx.fill();

            // --- New Texture Facets (Pink Details) ---

            // 1. Crevice/Shadow on the main face (P1, T_A, T_B)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y);
            ctx.lineTo(T_A.x, T_A.y);
            ctx.lineTo(T_B.x, T_B.y);
            ctx.closePath();
            ctx.fillStyle = textureCreviceColor;
            ctx.fill();

            // 2. Small highlight near the peak (P0, P1, T_A)
            ctx.beginPath();
            ctx.moveTo(P0.x, P0.y);
            ctx.lineTo(P1.x, P1.y);
            ctx.lineTo(T_A.x, T_A.y);
            ctx.closePath();
            ctx.fillStyle = textureHighlightColor;
            ctx.fill();

            // 3. Ridge near the left waterline (T_C, P5, T_D)
            ctx.beginPath();
            ctx.moveTo(T_C.x, T_C.y);
            ctx.lineTo(P5.x, P5.y);
            ctx.lineTo(T_D.x, T_D.y);
            ctx.closePath();
            ctx.fillStyle = textureCreviceColor;
            ctx.fill();

            // 4. Highlight on the right side (P3, T_B, P4)
            ctx.beginPath();
            ctx.moveTo(P3.x, P3.y);
            ctx.lineTo(T_B.x, T_B.y);
            ctx.lineTo(P4.x, P4.y);
            ctx.closePath();
            ctx.fillStyle = textureHighlightColor;
            ctx.fill();


            // --- 5. Draw Water Line Overlay (Last to ensure it's on top) ---
            // Crisp Neon Green line
            ctx.beginPath();
            ctx.moveTo(0, waterLevelY);
            ctx.lineTo(W, waterLevelY);
            ctx.strokeStyle = '#34D399'; // Neon Green
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        /**
         * Parses the URL hash to check for a simulated date.
         * @returns {Date | null} The simulated Date object, or null if not found/invalid.
         */
        function getRundownDate() {
            const hash = window.location.hash.substring(1); // Remove '#'
            const params = new URLSearchParams(hash);
            const dateStr = params.get('date');

            if (dateStr) {
                try {
                    const date = new Date(dateStr);
                    // Check if the date is valid (e.g., not "Invalid Date")
                    if (!isNaN(date.getTime())) {
                        return date;
                    }
                } catch (e) {
                    console.error("Invalid date format in hash:", dateStr);
                }
            }
            return null;
        }

        /**
         * Main function to run the calculation and drawing.
         */
        function updateDisplay() {
            const simulatedDate = getRundownDate();
            
            let daysRemaining;
            let displayTitle;

            if (simulatedDate) {
                daysRemaining = calculateDaysRemaining(simulatedDate);
                // Format the simulated date for display
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                const formattedDate = simulatedDate.toLocaleDateString(undefined, options);
                displayTitle = `Simulation for ${formattedDate}`;
            } else {
                daysRemaining = calculateDaysRemaining(new Date());
                displayTitle = `Days of School Remaining`;
            }
            
            // Update the HTML text
            document.getElementById('subtitle').textContent = displayTitle;
            const countdownEl = document.getElementById('countdown');
            countdownEl.textContent = daysRemaining;
            
            // Adjust color based on remaining days (using dark-mode appropriate alerts)
            if (daysRemaining <= 10) {
                countdownEl.classList.remove('bg-green-500', 'bg-yellow-500');
                countdownEl.classList.add('bg-red-600');
                countdownEl.classList.remove('text-neutral-900');
                countdownEl.classList.add('text-white');
            } else if (daysRemaining <= 20) {
                countdownEl.classList.remove('bg-green-500', 'bg-red-600');
                countdownEl.classList.add('bg-yellow-500');
                countdownEl.classList.remove('text-white');
                countdownEl.classList.add('text-neutral-900');
            } else {
                countdownEl.classList.remove('bg-red-600', 'bg-yellow-500');
                countdownEl.classList.add('bg-green-500');
                countdownEl.classList.remove('text-white');
                countdownEl.classList.add('text-neutral-900');
            }


            // Draw the iceberg
            const canvas = document.getElementById('icebergCanvas');
            // Ensure canvas size is set to the container size before drawing
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight; 
            drawIceberg(daysRemaining);
        }
        
        // --- Initialization and Event Listeners ---
        window.addEventListener('DOMContentLoaded', updateDisplay);
        window.addEventListener('resize', updateDisplay);
        // New: Listen for URL hash changes to run the simulation
        window.addEventListener('hashchange', updateDisplay);

    </script>
</body>
</html>