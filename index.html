<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Days Countdown</title>
    <!-- Tailwind CSS for modern, responsive styling --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas container */
        .canvas-container {
            max-width: 600px;
            width: 90%;
            margin: 0 auto;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            background-color: #f7fafc; /* Tailwind gray-50 */
            overflow: hidden;
        }
        #icebergCanvas {
            display: block;
            width: 100%;
            height: 400px; /* Fixed height for the drawing area */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <div class="text-center mb-10 w-full max-w-xl">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-900 mb-2">
            Countdown to Freedom!
        </h1>
        <p id="subtitle" class="text-gray-600 text-lg mb-6">Days of School Remaining</p>
        <div id="countdown" class="text-6xl sm:text-8xl font-black text-white p-6 rounded-xl bg-blue-600 shadow-xl transition duration-300">
            Calculating...
        </div>
    </div>

    <!-- Canvas Container for the Iceberg Visualization --><div class="canvas-container shadow-2xl">
        <canvas id="icebergCanvas"></canvas>
    </div>

    <script>
        // --- Configuration Constants ---
        // The total number of school days, confirmed to be 40 (Tue-Fri only).
        const MAX_SCHOOL_DAYS = 40; 
        const START_DATE_STR = '2025-11-25T00:00:00'; // First day (Day 40 remaining)
        const BREAK_START_STR = '2025-12-20T00:00:00'; // Holiday starts (Dec 20th is the first non-school day)
        const BREAK_END_STR = '2026-01-06T00:00:00'; // School resumes (Jan 6th IS counted)
        
        const START_DATE = new Date(START_DATE_STR);
        const BREAK_START = new Date(BREAK_START_STR);
        const BREAK_END_EXCLUSIVE = new Date(BREAK_END_STR);
        
        /**
         * Checks if a given date is a school day based on the defined rules (Tue-Fri only).
         * @param {Date} date - The date to check.
         * @returns {boolean} True if it is a school day.
         */
        function isSchoolDay(date) {
            // Day of week: 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
            const day = date.getDay();

            // 1. Check for Non-School Days (Mon, Sat, Sun)
            // Days 0 (Sun), 1 (Mon), and 6 (Sat) are excluded.
            if (day === 0 || day === 1 || day === 6) {
                return false;
            }

            // 2. Check Holiday Break (Dec 20, 2025 up to Jan 5, 2026, inclusive)
            // Note: Jan 6th (BREAK_END_EXCLUSIVE) IS counted.
            if (date >= BREAK_START && date < BREAK_END_EXCLUSIVE) {
                return false;
            }

            return true;
        }

        /**
         * Calculates the number of remaining school days up to a given date.
         * @param {Date} simulatedDate - The date to calculate up to (defaults to today).
         */
        function calculateDaysRemaining(simulatedDate = new Date()) {
            const checkDate = new Date(simulatedDate);
            // Reset time to midnight for accurate day comparison
            checkDate.setHours(0, 0, 0, 0);

            // If the date is before the start date, the full count remains
            if (checkDate < START_DATE) {
                return MAX_SCHOOL_DAYS;
            }

            let daysBeforeTarget = 0;
            let currentDate = new Date(START_DATE);

            // Iterate through every day from START_DATE up to (but not including) the target date
            while (currentDate < checkDate) {
                if (isSchoolDay(currentDate)) {
                    daysBeforeTarget++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Days remaining = Total count (40) - Days elapsed
            // The 40th and final school day is now correctly calculated as February 13th, 2026.
            const daysRemaining = Math.max(0, MAX_SCHOOL_DAYS - daysBeforeTarget);
            
            return daysRemaining;
        }

        /**
         * Draws the dynamic iceberg visualization on the canvas, matching the reference image.
         * @param {number} daysRemaining - The current number of school days left (0 to 40).
         */
        function drawIceberg(daysRemaining) {
            const canvas = document.getElementById('icebergCanvas');
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;
            ctx.clearRect(0, 0, W, H);

            // Calculate progress: 0 (Day MAX_SCHOOL_DAYS) to 1 (Day 0)
            const progress = (MAX_SCHOOL_DAYS - daysRemaining) / MAX_SCHOOL_DAYS;

            // --- Drawing Parameters ---
            const centerX = W / 2;
            const waterLevelY = H * 0.5; // Fixed water line
            const baseScale = W * 0.25; // Overall scale for the iceberg size

            // Dynamic adjustments based on progress
            const peakLift = baseScale * 0.2 * progress; // How much the peak moves down (chipping)
            const totalVerticalShift = baseScale * 0.3 * progress; // Overall rise of the iceberg (buoyancy)
            const widthShrink = baseScale * 0.15 * progress; // How much the width shrinks


            // --- 1. Draw Water and Sky ---
            // Sky
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, W, waterLevelY);

            // Water (Deep Ocean)
            ctx.fillStyle = '#106dae';
            ctx.fillRect(0, waterLevelY, W, H - waterLevelY);


            // --- 2. Define Iceberg Points (Relative to centerX, waterLevelY, and scale) ---
            
            // Internal Texture Points (T1-T4)
            const T1 = {x: -0.05 * baseScale + widthShrink * 0.3, y: -0.4 * baseScale + peakLift * 0.6}; // High Center Left
            const T2 = {x: 0.15 * baseScale - widthShrink * 0.4, y: -0.5 * baseScale + peakLift * 0.7}; // High Center Right
            const T3 = {x: -0.18 * baseScale + widthShrink * 0.6, y: -0.2 * baseScale + peakLift * 0.4}; // Low Left Ridge
            const T4 = {x: 0.05 * baseScale - widthShrink * 0.1, y: -0.15 * baseScale + peakLift * 0.3}; // Low Center Ridge

            // Visible Part Points (P0-P6)
            const topPoints = [
                {x: -0.1 * baseScale + widthShrink * 0.5, y: -0.7 * baseScale + peakLift}, // P0: Left-most peak facet
                {x: 0 * baseScale, y: -0.8 * baseScale + peakLift}, // P1: Main peak
                {x: 0.1 * baseScale - widthShrink * 0.5, y: -0.7 * baseScale + peakLift}, // P2: Right-most peak facet
                {x: 0.3 * baseScale - widthShrink, y: -0.3 * baseScale + peakLift * 0.5}, // P3: Far right middle
                {x: 0.25 * baseScale - widthShrink * 0.7, y: 0 * baseScale}, // P4: Right waterline (WL_R)
                {x: -0.25 * baseScale + widthShrink * 0.7, y: 0 * baseScale}, // P5: Left waterline (WL_L)
                {x: -0.3 * baseScale + widthShrink, y: -0.3 * baseScale + peakLift * 0.5}, // P6: Far left middle
            ];

            // Submerged Part Points
            const submergedPoints = [
                {x: -0.25 * baseScale + widthShrink * 0.7, y: 0 * baseScale}, // P0: Left waterline (matches visible)
                {x: 0.25 * baseScale - widthShrink * 0.7, y: 0 * baseScale}, // P1: Right waterline (matches visible)
                {x: 0.25 * baseScale - widthShrink * 0.8, y: 0.3 * baseScale + totalVerticalShift}, // P2: Right-lower-side
                {x: 0.15 * baseScale - widthShrink * 0.5, y: 0.6 * baseScale + totalVerticalShift * 0.8}, // P3: Lower-right deep
                {x: 0 * baseScale, y: 0.8 * baseScale + totalVerticalShift * 0.6}, // P4: Bottom tip
                {x: -0.15 * baseScale + widthShrink * 0.5, y: 0.6 * baseScale + totalVerticalShift * 0.8}, // P5: Lower-left deep
                {x: -0.25 * baseScale + widthShrink * 0.8, y: 0.3 * baseScale + totalVerticalShift}, // P6: Left-lower-side
            ];

            // Helper to offset points to canvas coordinates
            const offsetPoints = (points, offsetY = waterLevelY) => points.map(p => ({
                x: centerX + p.x,
                y: offsetY + p.y
            }));

            const visiblePts = offsetPoints(topPoints, waterLevelY);
            const submergedPts = offsetPoints(submergedPoints, waterLevelY);
            const internalPts = offsetPoints([T1, T2, T3, T4], waterLevelY);

            // Alias key points for drawing clarity
            const P0 = visiblePts[0]; const P1 = visiblePts[1]; const P2 = visiblePts[2];
            const P3 = visiblePts[3]; const P4 = visiblePts[4]; const P5 = visiblePts[5];
            const P6 = visiblePts[6];
            const T_A = internalPts[0]; const T_B = internalPts[1];
            const T_C = internalPts[2]; const T_D = internalPts[3];

            // --- 3. Draw Iceberg Submerged Part ---
            const submergedDarkBlue = '#1d71b3';
            const submergedLightBlue = '#2887cc';
            const submergedHighlightBlue = '#3a9ce6';

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Main submerged shape (darkest base)
            ctx.beginPath();
            ctx.moveTo(submergedPts[0].x, submergedPts[0].y); 
            ctx.lineTo(submergedPts[6].x, submergedPts[6].y); 
            ctx.lineTo(submergedPts[5].x, submergedPts[5].y); 
            ctx.lineTo(submergedPts[4].x, submergedPts[4].y); 
            ctx.lineTo(submergedPts[3].x, submergedPts[3].y); 
            ctx.lineTo(submergedPts[2].x, submergedPts[2].y); 
            ctx.lineTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.closePath();
            ctx.fillStyle = submergedDarkBlue;
            ctx.fill();

            // Lighter submerged facet (right side)
            ctx.beginPath();
            ctx.moveTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.lineTo(submergedPts[2].x, submergedPts[2].y); 
            ctx.lineTo(submergedPts[3].x, submergedPts[3].y); 
            ctx.closePath();
            ctx.fillStyle = submergedLightBlue;
            ctx.fill();

            // Submerged highlight (middle triangle)
            ctx.beginPath();
            ctx.moveTo(submergedPts[0].x, submergedPts[0].y); 
            ctx.lineTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.lineTo(submergedPts[4].x, submergedPts[4].y); 
            ctx.closePath();
            ctx.fillStyle = submergedHighlightBlue;
            ctx.fill();


            // --- 4. Draw Iceberg Visible Part (Including New Texture) ---
            const visibleLight = '#f0f8ff'; 
            const visibleMid = '#e0f2f7';
            const visibleDark = '#c7e9f4';
            const textureCreviceColor = '#D0F0FF'; // Blueish-white for depth
            const textureHighlightColor = '#FFFFFF'; // Pure white for shine


            // Main visible shape (largest face - visibleMid base)
            ctx.beginPath();
            ctx.moveTo(P5.x, P5.y); // Left waterline
            ctx.lineTo(P6.x, P6.y); // Far left middle
            ctx.lineTo(P0.x, P0.y); // Left-most peak facet
            ctx.lineTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P2.x, P2.y); // Right-most peak facet
            ctx.lineTo(P3.x, P3.y); // Far right middle
            ctx.lineTo(P4.x, P4.y); // Right waterline
            ctx.closePath();
            ctx.fillStyle = visibleMid;
            ctx.fill();

            // Front-right facet (lighter)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P2.x, P2.y); // Right-most peak facet
            ctx.lineTo(P3.x, P3.y); // Far right middle
            ctx.closePath();
            ctx.fillStyle = visibleLight;
            ctx.fill();
            
            // Front-left facet (darker)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P0.x, P0.y); // Left-most peak facet
            ctx.lineTo(P6.x, P6.y); // Far left middle
            ctx.closePath();
            ctx.fillStyle = visibleDark;
            ctx.fill();

            // --- New Texture Facets (Drawn on top for detail) ---

            // 1. Crevice/Shadow on the main face (P1, T_A, T_B)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y);
            ctx.lineTo(T_A.x, T_A.y);
            ctx.lineTo(T_B.x, T_B.y);
            ctx.closePath();
            ctx.fillStyle = textureCreviceColor;
            ctx.fill();

            // 2. Small highlight near the peak (P0, P1, T_A)
            ctx.beginPath();
            ctx.moveTo(P0.x, P0.y);
            ctx.lineTo(P1.x, P1.y);
            ctx.lineTo(T_A.x, T_A.y);
            ctx.closePath();
            ctx.fillStyle = textureHighlightColor;
            ctx.fill();

            // 3. Ridge near the left waterline (T_C, P5, T_D)
            ctx.beginPath();
            ctx.moveTo(T_C.x, T_C.y);
            ctx.lineTo(P5.x, P5.y);
            ctx.lineTo(T_D.x, T_D.y);
            ctx.closePath();
            ctx.fillStyle = textureCreviceColor;
            ctx.fill();

            // 4. Highlight on the right side (P3, T_B, P4)
            ctx.beginPath();
            ctx.moveTo(P3.x, P3.y);
            ctx.lineTo(T_B.x, T_B.y);
            ctx.lineTo(P4.x, P4.y);
            ctx.closePath();
            ctx.fillStyle = textureHighlightColor;
            ctx.fill();


            // --- 5. Draw Water Line Overlay and Ripple ---
            
            // Subtle water reflection/ripple (drawn over the water/ice interface)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Semi-transparent white
            ctx.lineWidth = 1;

            // Draw several undulating lines for the ripple effect
            for (let i = 0; i < 5; i++) {
                const yOffset = waterLevelY + 5 + i * 3;
                // Create dynamic wave-like offsets based on current progress
                const startX = Math.sin(i * 0.5 + progress * 5) * 5 + W * 0.1;
                const endX = W - (Math.cos(i * 0.5 + progress * 5) * 5 + W * 0.1);

                ctx.beginPath();
                ctx.moveTo(startX, yOffset);
                ctx.bezierCurveTo(
                    W * 0.3 + Math.random() * 20, yOffset + Math.sin(i + progress * 10) * 2,
                    W * 0.7 - Math.random() * 20, yOffset - Math.cos(i + progress * 10) * 2,
                    endX, yOffset
                );
                ctx.stroke();
            }

            // Crisp white line (must be last to ensure it's on top)
            ctx.beginPath();
            ctx.moveTo(0, waterLevelY);
            ctx.lineTo(W, waterLevelY);
            ctx.strokeStyle = '#ffffff'; 
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        /**
         * Parses the URL hash to check for a simulated date.
         * @returns {Date | null} The simulated Date object, or null if not found/invalid.
         */
        function getRundownDate() {
            const hash = window.location.hash.substring(1); // Remove '#'
            const params = new URLSearchParams(hash);
            const dateStr = params.get('date');

            if (dateStr) {
                try {
                    const date = new Date(dateStr);
                    // Check if the date is valid (e.g., not "Invalid Date")
                    if (!isNaN(date.getTime())) {
                        return date;
                    }
                } catch (e) {
                    console.error("Invalid date format in hash:", dateStr);
                }
            }
            return null;
        }

        /**
         * Main function to run the calculation and drawing.
         */
        function updateDisplay() {
            const simulatedDate = getRundownDate();
            
            let daysRemaining;
            let displayTitle;

            if (simulatedDate) {
                daysRemaining = calculateDaysRemaining(simulatedDate);
                // Format the simulated date for display
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                const formattedDate = simulatedDate.toLocaleDateString(undefined, options);
                displayTitle = `Simulation for ${formattedDate}`;
            } else {
                daysRemaining = calculateDaysRemaining(new Date());
                displayTitle = `Days of School Remaining`;
            }
            
            // Update the HTML text
            document.getElementById('subtitle').textContent = displayTitle;
            const countdownEl = document.getElementById('countdown');
            countdownEl.textContent = daysRemaining;
            
            // Adjust color based on remaining days
            if (daysRemaining <= 10) {
                countdownEl.classList.remove('bg-blue-600', 'bg-yellow-500');
                countdownEl.classList.add('bg-red-500');
            } else if (daysRemaining <= 20) {
                countdownEl.classList.remove('bg-blue-600', 'bg-red-500');
                countdownEl.classList.add('bg-yellow-500');
            } else {
                countdownEl.classList.remove('bg-red-500', 'bg-yellow-500');
                countdownEl.classList.add('bg-blue-600');
            }


            // Draw the iceberg
            const canvas = document.getElementById('icebergCanvas');
            // Ensure canvas size is set to the container size before drawing
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight; 
            drawIceberg(daysRemaining);
        }
        
        // --- Initialization and Event Listeners ---
        window.addEventListener('DOMContentLoaded', updateDisplay);
        window.addEventListener('resize', updateDisplay);
        // New: Listen for URL hash changes to run the simulation
        window.addEventListener('hashchange', updateDisplay);

    </script>
</body>
</html>