<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>School Days Countdown</title>
    <!-- Tailwind CSS for modern, responsive styling --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas container */
        .canvas-container {
            max-width: 600px;
            width: 90%;
            margin: 0 auto;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            background-color: #f7fafc; /* Tailwind gray-50 */
            overflow: hidden;
        }
        #icebergCanvas {
            display: block;
            width: 100%;
            height: 400px; /* Fixed height for the drawing area */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <div class="text-center mb-10 w-full max-w-xl">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-900 mb-2">
            Countdown to Freedom!
        </h1>
        <p id="subtitle" class="text-gray-600 text-lg mb-6">Days of School Remaining</p>
        <div id="countdown" class="text-6xl sm:text-8xl font-black text-white p-6 rounded-xl bg-blue-600 shadow-xl transition duration-300">
            Calculating...
        </div>
    </div>

    <!-- Canvas Container for the Iceberg Visualization --><div class="canvas-container shadow-2xl">
        <canvas id="icebergCanvas"></canvas>
    </div>

    <script>
        // --- Configuration Constants ---
        // The total number of school days, confirmed to be 40 (Tue-Fri only).
        const MAX_SCHOOL_DAYS = 40; 
        const START_DATE_STR = '2025-11-25T00:00:00'; // First day (Day 40 remaining)
        const BREAK_START_STR = '2025-12-20T00:00:00'; // Holiday starts (Dec 20th is the first non-school day)
        const BREAK_END_STR = '2026-01-06T00:00:00'; // School resumes (Jan 6th IS counted)
        
        const START_DATE = new Date(START_DATE_STR);
        const BREAK_START = new Date(BREAK_START_STR);
        const BREAK_END_EXCLUSIVE = new Date(BREAK_END_STR);
        
        /**
         * Checks if a given date is a school day based on the defined rules (Tue-Fri only).
         * @param {Date} date - The date to check.
         * @returns {boolean} True if it is a school day.
         */
        function isSchoolDay(date) {
            // Day of week: 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
            const day = date.getDay();

            // 1. Check for Non-School Days (Mon, Sat, Sun)
            // Days 0 (Sun), 1 (Mon), and 6 (Sat) are excluded.
            if (day === 0 || day === 1 || day === 6) {
                return false;
            }

            // 2. Check Holiday Break (Dec 20, 2025 up to Jan 5, 2026, inclusive)
            // Note: Jan 6th (BREAK_END_EXCLUSIVE) IS counted.
            if (date >= BREAK_START && date < BREAK_END_EXCLUSIVE) {
                return false;
            }

            return true;
        }

        /**
         * Calculates the number of remaining school days up to a given date.
         * @param {Date} simulatedDate - The date to calculate up to (defaults to today).
         */
        function calculateDaysRemaining(simulatedDate = new Date()) {
            const checkDate = new Date(simulatedDate);
            // Reset time to midnight for accurate day comparison
            checkDate.setHours(0, 0, 0, 0);

            // If the date is before the start date, the full count remains
            if (checkDate < START_DATE) {
                return MAX_SCHOOL_DAYS;
            }

            let daysBeforeTarget = 0;
            let currentDate = new Date(START_DATE);

            // Iterate through every day from START_DATE up to (but not including) the target date
            while (currentDate < checkDate) {
                if (isSchoolDay(currentDate)) {
                    daysBeforeTarget++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Days remaining = Total count (40) - Days elapsed
            const daysRemaining = Math.max(0, MAX_SCHOOL_DAYS - daysBeforeTarget);
            
            return daysRemaining;
        }

        /**
         * Draws the dynamic iceberg visualization on the canvas, matching the reference image.
         * @param {number} daysRemaining - The current number of school days left (0 to 40).
         */
        function drawIceberg(daysRemaining) {
            const canvas = document.getElementById('icebergCanvas');
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;
            ctx.clearRect(0, 0, W, H);

            // Calculate progress: 0 (Day MAX_SCHOOL_DAYS) to 1 (Day 0)
            const progress = (MAX_SCHOOL_DAYS - daysRemaining) / MAX_SCHOOL_DAYS;
            
            // Overall reduction factor (1.0 at day 40, approaches 0 at day 0)
            const sizeFactor = daysRemaining / MAX_SCHOOL_DAYS; 
            
            // The initial, maximum scale for geometry definitions
            const MAX_BASE_SCALE = W * 0.25; 
            
            // --- Drawing Parameters ---
            const centerX = W / 2;
            const waterLevelY = H * 0.5; // Fixed water line

            // Buoyancy: Lift the iceberg as it gets smaller (progress goes from 0 to 1)
            const verticalLift = MAX_BASE_SCALE * 0.2 * progress; 
            
            // Chipping: Introduce non-symmetrical, fixed variance based on remaining days.
            // This ensures the peak shifts slightly each day but is stable throughout the day.
            const shapingSeed = Math.sin(daysRemaining * 1.5 + daysRemaining / 5) * 0.5 + 0.5; // Predictable pseudo-random (0 to 1)
            const chippingVariance = MAX_BASE_SCALE * 0.1 * progress; // Max variance increases as it melts

            // --- 1. Draw Water and Sky ---
            // Sky
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, W, waterLevelY);

            // Water (Deep Ocean)
            ctx.fillStyle = '#106dae';
            ctx.fillRect(0, waterLevelY, W, H - waterLevelY);
            
            // Check if the iceberg is completely melted (Day 0)
            if (daysRemaining <= 0) {
                 // Skip drawing the iceberg geometry, only the water line remains
                 // Crisp white line
                ctx.beginPath();
                ctx.moveTo(0, waterLevelY);
                ctx.lineTo(W, waterLevelY);
                ctx.strokeStyle = '#ffffff'; 
                ctx.lineWidth = 4;
                ctx.stroke();
                return; 
            }


            // --- 2. Define Iceberg Points (Relative to centerX, waterLevelY, and MAX_BASE_SCALE) ---
            
            // All coordinates are multiplied by sizeFactor for smooth, proportional shrinking.
            
            // Internal Texture Points (T1-T4)
            const T1 = {
                x: (-0.05 * MAX_BASE_SCALE + chippingVariance * shapingSeed * 0.2) * sizeFactor, 
                y: (-0.4 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor
            };
            const T2 = {
                x: (0.15 * MAX_BASE_SCALE - chippingVariance * (1 - shapingSeed) * 0.2) * sizeFactor, 
                y: (-0.5 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor
            };
            const T3 = {
                x: (-0.18 * MAX_BASE_SCALE) * sizeFactor, 
                y: (-0.2 * MAX_BASE_SCALE + verticalLift * 0.8) * sizeFactor
            };
            const T4 = {
                x: (0.05 * MAX_BASE_SCALE) * sizeFactor, 
                y: (-0.15 * MAX_BASE_SCALE + verticalLift * 0.8) * sizeFactor
            };


            // Visible Part Points (P0-P6) - Applying chipping to the peak
            const topPoints = [
                // P0, P1, P2 are the peak points, get the most dramatic variance
                {x: (-0.1 * MAX_BASE_SCALE) * sizeFactor, y: (-0.7 * MAX_BASE_SCALE + verticalLift + chippingVariance * shapingSeed * 0.8) * sizeFactor}, 
                {x: (0 * MAX_BASE_SCALE + chippingVariance * (1 - shapingSeed) * 0.4) * sizeFactor, y: (-0.8 * MAX_BASE_SCALE + verticalLift + chippingVariance * (1 - shapingSeed) * 0.8) * sizeFactor}, 
                {x: (0.1 * MAX_BASE_SCALE) * sizeFactor, y: (-0.7 * MAX_BASE_SCALE + verticalLift - chippingVariance * shapingSeed * 0.8) * sizeFactor}, 
                
                {x: (0.3 * MAX_BASE_SCALE) * sizeFactor, y: (-0.3 * MAX_BASE_SCALE + verticalLift) * sizeFactor}, // P3: Far right middle
                {x: (0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P4: Right waterline (WL_R) - Should remain near zero vertical offset if sizeFactor is 0
                {x: (-0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P5: Left waterline (WL_L)
                {x: (-0.3 * MAX_BASE_SCALE) * sizeFactor, y: (-0.3 * MAX_BASE_SCALE + verticalLift) * sizeFactor}, // P6: Far left middle
            ];

            // Submerged Part Points (Symmetrically shrinking and rising)
            const submergedPoints = [
                {x: (-0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P0: Left waterline
                {x: (0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0 * MAX_BASE_SCALE) * sizeFactor}, // P1: Right waterline
                {x: (0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0.3 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor}, 
                {x: (0.15 * MAX_BASE_SCALE) * sizeFactor, y: (0.6 * MAX_BASE_SCALE + verticalLift * 0.2) * sizeFactor}, 
                {x: (0 * MAX_BASE_SCALE) * sizeFactor, y: (0.8 * MAX_BASE_SCALE + verticalLift * 0.1) * sizeFactor}, 
                {x: (-0.15 * MAX_BASE_SCALE) * sizeFactor, y: (0.6 * MAX_BASE_SCALE + verticalLift * 0.2) * sizeFactor}, 
                {x: (-0.25 * MAX_BASE_SCALE) * sizeFactor, y: (0.3 * MAX_BASE_SCALE + verticalLift * 0.5) * sizeFactor}, 
            ];

            // Helper to offset points to canvas coordinates
            const offsetPoints = (points, offsetY = waterLevelY) => points.map(p => ({
                x: centerX + p.x,
                y: offsetY + p.y
            }));

            const visiblePts = offsetPoints(topPoints, waterLevelY);
            const submergedPts = offsetPoints(submergedPoints, waterLevelY);
            const internalPts = offsetPoints([T1, T2, T3, T4], waterLevelY);

            // Alias key points for drawing clarity
            const P0 = visiblePts[0]; const P1 = visiblePts[1]; const P2 = visiblePts[2];
            const P3 = visiblePts[3]; const P4 = visiblePts[4]; const P5 = visiblePts[5];
            const P6 = visiblePts[6];
            const T_A = internalPts[0]; const T_B = internalPts[1];
            const T_C = internalPts[2]; const T_D = internalPts[3];

            // --- 3. Draw Iceberg Submerged Part ---
            const submergedDarkBlue = '#1d71b3';
            const submergedLightBlue = '#2887cc';
            const submergedHighlightBlue = '#3a9ce6';

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Main submerged shape (darkest base)
            ctx.beginPath();
            ctx.moveTo(submergedPts[0].x, submergedPts[0].y); 
            ctx.lineTo(submergedPts[6].x, submergedPts[6].y); 
            ctx.lineTo(submergedPts[5].x, submergedPts[5].y); 
            ctx.lineTo(submergedPts[4].x, submergedPts[4].y); 
            ctx.lineTo(submergedPts[3].x, submergedPts[3].y); 
            ctx.lineTo(submergedPts[2].x, submergedPts[2].y); 
            ctx.lineTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.closePath();
            ctx.fillStyle = submergedDarkBlue;
            ctx.fill();

            // Lighter submerged facet (right side)
            ctx.beginPath();
            ctx.moveTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.lineTo(submergedPts[2].x, submergedPts[2].y); 
            ctx.lineTo(submergedPts[3].x, submergedPts[3].y); 
            ctx.closePath();
            ctx.fillStyle = submergedLightBlue;
            ctx.fill();

            // Submerged highlight (middle triangle)
            ctx.beginPath();
            ctx.moveTo(submergedPts[0].x, submergedPts[0].y); 
            ctx.lineTo(submergedPts[1].x, submergedPts[1].y); 
            ctx.lineTo(submergedPts[4].x, submergedPts[4].y); 
            ctx.closePath();
            ctx.fillStyle = submergedHighlightBlue;
            ctx.fill();


            // --- 4. Draw Iceberg Visible Part (Including New Texture) ---
            const visibleLight = '#f0f8ff'; 
            const visibleMid = '#e0f2f7';
            const visibleDark = '#c7e9f4';
            const textureCreviceColor = '#D0F0FF'; // Blueish-white for depth
            const textureHighlightColor = '#FFFFFF'; // Pure white for shine


            // Main visible shape (largest face - visibleMid base)
            ctx.beginPath();
            ctx.moveTo(P5.x, P5.y); // Left waterline
            ctx.lineTo(P6.x, P6.y); // Far left middle
            ctx.lineTo(P0.x, P0.y); // Left-most peak facet
            ctx.lineTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P2.x, P2.y); // Right-most peak facet
            ctx.lineTo(P3.x, P3.y); // Far right middle
            ctx.lineTo(P4.x, P4.y); // Right waterline
            ctx.closePath();
            ctx.fillStyle = visibleMid;
            ctx.fill();

            // Front-right facet (lighter)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P2.x, P2.y); // Right-most peak facet
            ctx.lineTo(P3.x, P3.y); // Far right middle
            ctx.closePath();
            ctx.fillStyle = visibleLight;
            ctx.fill();
            
            // Front-left facet (darker)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y); // Main peak
            ctx.lineTo(P0.x, P0.y); // Left-most peak facet
            ctx.lineTo(P6.x, P6.y); // Far left middle
            ctx.closePath();
            ctx.fillStyle = visibleDark;
            ctx.fill();

            // --- New Texture Facets (Drawn on top for detail) ---

            // 1. Crevice/Shadow on the main face (P1, T_A, T_B)
            ctx.beginPath();
            ctx.moveTo(P1.x, P1.y);
            ctx.lineTo(T_A.x, T_A.y);
            ctx.lineTo(T_B.x, T_B.y);
            ctx.closePath();
            ctx.fillStyle = textureCreviceColor;
            ctx.fill();

            // 2. Small highlight near the peak (P0, P1, T_A)
            ctx.beginPath();
            ctx.moveTo(P0.x, P0.y);
            ctx.lineTo(P1.x, P1.y);
            ctx.lineTo(T_A.x, T_A.y);
            ctx.closePath();
            ctx.fillStyle = textureHighlightColor;
            ctx.fill();

            // 3. Ridge near the left waterline (T_C, P5, T_D)
            ctx.beginPath();
            ctx.moveTo(T_C.x, T_C.y);
            ctx.lineTo(P5.x, P5.y);
            ctx.lineTo(T_D.x, T_D.y);
            ctx.closePath();
            ctx.fillStyle = textureCreviceColor;
            ctx.fill();

            // 4. Highlight on the right side (P3, T_B, P4)
            ctx.beginPath();
            ctx.moveTo(P3.x, P3.y);
            ctx.lineTo(T_B.x, T_B.y);
            ctx.lineTo(P4.x, P4.y);
            ctx.closePath();
            ctx.fillStyle = textureHighlightColor;
            ctx.fill();


            // --- 5. Draw Water Line Overlay and Ripple ---
            
            // Subtle water reflection/ripple (drawn over the water/ice interface)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Semi-transparent white
            ctx.lineWidth = 1;

            // Draw several undulating lines for the ripple effect
            for (let i = 0; i < 5; i++) {
                const yOffset = waterLevelY + 5 + i * 3;
                // Create dynamic wave-like offsets based on current progress
                const startX = Math.sin(i * 0.5 + progress * 5) * 5 + W * 0.1;
                const endX = W - (Math.cos(i * 0.5 + progress * 5) * 5 + W * 0.1);

                ctx.beginPath();
                ctx.moveTo(startX, yOffset);
                ctx.bezierCurveTo(
                    W * 0.3 + Math.random() * 20, yOffset + Math.sin(i + progress * 10) * 2,
                    W * 0.7 - Math.random() * 20, yOffset - Math.cos(i + progress * 10) * 2,
                    endX, yOffset
                );
                ctx.stroke();
            }

            // Crisp white line (must be last to ensure it's on top)
            ctx.beginPath();
            ctx.moveTo(0, waterLevelY);
            ctx.lineTo(W, waterLevelY);
            ctx.strokeStyle = '#ffffff'; 
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        /**
         * Parses the URL hash to check for a simulated date.
         * @returns {Date | null} The simulated Date object, or null if not found/invalid.
         */
        function getRundownDate() {
            const hash = window.location.hash.substring(1); // Remove '#'
            const params = new URLSearchParams(hash);
            const dateStr = params.get('date');

            if (dateStr) {
                try {
                    const date = new Date(dateStr);
                    // Check if the date is valid (e.g., not "Invalid Date")
                    if (!isNaN(date.getTime())) {
                        return date;
                    }
                } catch (e) {
                    console.error("Invalid date format in hash:", dateStr);
                }
            }
            return null;
        }

        /**
         * Main function to run the calculation and drawing.
         */
        function updateDisplay() {
            const simulatedDate = getRundownDate();
            
            let daysRemaining;
            let displayTitle;

            if (simulatedDate) {
                daysRemaining = calculateDaysRemaining(simulatedDate);
                // Format the simulated date for display
                const options = { year: 'numeric', month: 'long', day: 'numeric' };
                const formattedDate = simulatedDate.toLocaleDateString(undefined, options);
                displayTitle = `Simulation for ${formattedDate}`;
            } else {
                daysRemaining = calculateDaysRemaining(new Date());
                displayTitle = `Days of School Remaining`;
            }
            
            // Update the HTML text
            document.getElementById('subtitle').textContent = displayTitle;
            const countdownEl = document.getElementById('countdown');
            countdownEl.textContent = daysRemaining;
            
            // Adjust color based on remaining days
            if (daysRemaining <= 10) {
                countdownEl.classList.remove('bg-blue-600', 'bg-yellow-500');
                countdownEl.classList.add('bg-red-500');
            } else if (daysRemaining <= 20) {
                countdownEl.classList.remove('bg-blue-600', 'bg-red-500');
                countdownEl.classList.add('bg-yellow-500');
            } else {
                countdownEl.classList.remove('bg-red-500', 'bg-yellow-500');
                countdownEl.classList.add('bg-blue-600');
            }


            // Draw the iceberg
            const canvas = document.getElementById('icebergCanvas');
            // Ensure canvas size is set to the container size before drawing
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight; 
            drawIceberg(daysRemaining);
        }
        
        // --- Initialization and Event Listeners ---
        window.addEventListener('DOMContentLoaded', updateDisplay);
        window.addEventListener('resize', updateDisplay);
        // New: Listen for URL hash changes to run the simulation
        window.addEventListener('hashchange', updateDisplay);

    </script>
</body>
</html>